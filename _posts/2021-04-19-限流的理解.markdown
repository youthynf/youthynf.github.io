---
title: 你对限流了解多少
author: ynf
date: 2021-04-19 18:23:31 +0800
categories: [计算机网络]
tags: [限流]
---
### 什么是限流
限流的本质是因为后端处理能力有限，需要截掉超过处理能力之外的请求，亦或是为了均衡客户端对服务端资源的公平调用，防止一些客户端饿死。

### 常见的限流算法
#### 1. 计数限流
最简单的限流算法就是计数限流了，具体实现流程：

例如系统能同时处理 100 个请求，保存一个计数器，处理了一个请求，计数器就加一，一个请求处理完毕之后计数器减一。每次请求来的时候看看计数器的值，如果超过阈值就拒绝。

如果放在第三方存储里，例如 Redis 中，集群机器访问就算分布式限流算法。

优点就是：简单粗暴，单机在 Java 中可用 Atomic 等原子类、分布式就 Redis incr。

缺点就是：假设我们允许的阈值是1万，此时计数器的值为 0， 当 1 万个请求在前 1 秒内一股脑儿的都涌进来，这突发的流量可是顶不住的。

#### 2. 固定窗口临界问题
它相比于计数限流主要是多了个时间窗口的概念，计数器每过一个时间窗口就重置。规则如下：
- 请求次数小于阈值，允许访问并且计数器 +1；
- 请求次数大于阈值，拒绝访问；
- 这个时间窗口过了之后，计数器清零；

**固定窗口临界问题**

在时间窗口即将结束时，涌进第一波请求，随后时间窗口刚过，刚重置完成，又涌进来一波请求，而这两波请求的时间间隔小于或等于一个时间窗口的长度，此时相当于一个时间窗口内涌进了两波请求，而这两波请求之和很可能就超出系统的接收范围。

#### 3. 滑动窗口限流
滑动窗口限流解决固定窗口临界值的问题，可以保证在任意时间窗口内都不会超过阈值。

相对于固定窗口，滑动窗口除了需要引入计数器之外还需要记录时间窗口内每个请求到达的时间点，因此对内存的占用会比较多。规则如下，假设时间窗口为 1 秒：
- 记录每次请求的时间
- 统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。
- 统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。

但是滑动窗口和固定窗口都无法解决短时间之内集中流量的突击。即无法保证请求的频率，很可能几毫秒内就打满了阈值。

滑动窗口和TCP的滑动窗口不一样，TCP的滑动窗口是接收方告知发送方自己能接多少“货”，然后发送方控制发送的速率。

#### 4. 漏桶算法
把请求当作是水滴，服务器看作是漏桶，每个请求过来往桶里滴，然后漏桶以固定的速率往下漏，水滴过快超出漏桶的容量范围时，就会溢出。
规则如下：
- 请求来了放入桶中
- 桶内请求量满了拒绝请求
- 服务定速从桶内拿请求处理

它的特点就是宽进严出，无论请求多少，请求的速率有多大，都按照固定的速率流出，对应的就是服务按照固定的速率处理请求。

一般而言漏桶也是由队列来实现的，处理不过来的请求就排队，队列满了就开始拒绝请求。

#### 5. 令牌桶算法
令牌桶其实和漏桶的原理类似，只不过漏桶是定速地流出，而令牌桶是定速地往桶里塞入令牌，然后请求只有拿到了令牌才能通过，之后再被服务器处理。

当然令牌桶的大小也是有限制的，假设桶里的令牌满了之后，定速生成的令牌会丢弃。

规则：
- 定速的往桶内放入令牌
- 令牌数量超过桶的限制，丢弃
- 请求来了先向桶内索要令牌，索要成功则通过被处理，反之拒绝

Semaphore 信号量啊，信号量可控制某个资源被同时访问的个数，其实和咱们拿令牌思想一样，一个是拿信号量，一个是拿令牌。只不过信号量用完了返还，而咱们令牌用了不归还，因为令牌会定时再填充。

### 限流组件
一般而言，我们不需要自己实现限流算法来达到限流的目的，不管是接入层限流还是细粒度的接口限流，都有现成的轮子使用，其实现也是用了上述我们所说的限流算法。

比如Google Guava 提供的限流工具类 RateLimiter，是基于令牌桶实现的，并且扩展了算法，支持预热功能。

阿里开源的限流框架Sentinel 中的匀速排队限流策略，就采用了漏桶算法。

Nginx 中的限流模块 limit_req_zone，采用了漏桶算法，还有 OpenResty 中的 resty.limit.req库等等。
