---
title: MySQL备忘笔记
author: ynf
date: 2021-04-20 11:23:31 +0800
categories: [数据库]
tags: [MySQL]
---
## **数据库三大范式是什么**
第一范式：每个列都不可再分；

第二范式：在第一范式的基础上，所有列都必须完全依赖于主键，而不能只依赖主键的一部分；

第三范式：在第二范式的基础上，非主键列只能依赖于主键列，而不能依赖于非主键列；

在设计数据库时要尽量遵循三大范式，如果不遵循必须要有充足的理由，比如性能考虑，会采用适当的字段冗余来减少连表操作。

## **MySQL的binlog有几种录入格式？分别有什么区别？**
MySQL的binglog一共有3中录入格式，分别是：statement、row、mixed。

**statement**：只记录会修改的sql，以及执行sql的上下文信息，不会记录每一行记录的具体修改，减少了binlog的日志量，减少IO，提高效率，但是某些函数的执行不会记录日志；

**row**：记录每一行的修改，不会记录sql执行的上下文信息，全部日志都会记录，但是遇到表结构修改时，会产生大量的日志。

**mixed**：折中的处理方法，一般情况下使用statement格式，当statement无法使用时使用row格式录入。

新版的mysql对row格式录入做了优化，当表结构发生改变时，只记录sql，不会记录每行的改变；

## **mysql有哪些数据类型**
**整数类型**：tinyint、smallint、mediumint、int、bigint，分别是1字节，2字节，3字节，4字节，8字节。其中长度只是限制了显示字符个数，而没有限制字段的写入范围，长度需要配合unsigned才有意义；

**实数类型**：float、double、decimal，decimal可以表示比bigint还大的整型，并且存储精确的小数，float是单精度浮点数，double是双精度浮点数，有取值范围，能做近似值计算；计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。

**字符串类型**：char、varchar、text、blobvarchar，其中char是定长字符，固定存储空间，内容会被截断，长度不足时，尾端用空格填充，而varchar是不定长字符串类型，用1个或2个字节记录长度，但字符串长度不足255字节时，使用1个字节记录长度，超过255时用2个字节记录长度，存储的内容超出设置的长度时，内容会被截断。

使用策略：

对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。

对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。

使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。

**枚举类型（ENUM）**：把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到1个或2个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数；

**日期和时间类型**：尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。

## **MySQL存储引擎MyISAM与InnoDB区别**
1. 事务：InnoDB提供了对数据库的ACID事务支持，而MyISAM不提供事务支持；

2. 锁：InnoDB支持表级锁、行级锁，支持外键，而MyISAM只支持表级锁，并且不支持外键；

3. 索引：

① InnoDB索引是聚簇索引，数据和索引是集中存储的（.ibd），而MyISAM是非聚簇索引，数据和索引文件是分别存储的（数据是.MYD，索引是.MYI)；InnoDB记录存储顺序是按逐渐大小有序插入，而MyISAM是按插入顺序保存，在索引中键值有序,数据还是无序的。

② MyISAM支持全文索引，InnoDB1.2.x版本开始支持全文检索。

③ InnoDB的主键索引的叶子节点存储着行数据，而MyISAM索引的叶子节点存放的是行数据的地址，还需要再寻址一次；

## **InnoDB引擎的4大特性**
- 插入缓冲（insertbuffer)

对于非聚集索引的插入，先去判断我要插入的索引页是否已经在内存中了，如果存在，就直接插入，如果不在，我暂时不着急先把索引页加载到内存中，而是把它放到了一个Insert Buffer对象中，临时先放在这，然后以一定的频率将Insert Buffer和要插入的非聚集索引页进行合并。（必须是辅助索引，并且非唯一）

- 二次写(doublewrite)

当发生数据库宕机，可能innodb正在写入某个数据页到表中，而这个数据页只写了一部分，这种情况我们称之为"部分写失效"，很容易出现数据丢失的问题。

这种情况下，我们可能会想到通过redo log进行恢复，这是一个办法，但是也存在一些小问题，因为redo log记录的是对数据页的操作，如果这个数据页已经发生了损坏，这种情况下对数据页进行重做是没有意义的，我们必须保证有一个数据页的副本，通过数据页的副本来还原这个数据页，再进行重做，这就是我们所说的二次写，也称之为doublewrite。

具体流程：当我们需要对缓冲池中的脏页刷洗进磁盘时，我们会先将脏页复制到内存的double buffer中，大小是2MB，之后通过缓存，分两次，每次1MB地写入到共享表空间的物理磁盘上（128个数据页*16K=2MB），完成之后立马同步磁盘，这样，一份数据在磁盘上就有两个副本了。

如果在写入磁盘的时候出现了问题，innodb将会在共享表空间的doublewrite中找到该数据页的一个副本，将其复制到表空间文件，再应用重做日志，也就是redo log。

- 自适应哈希索引(ahi)

哈希（hash）是一种非常快的查找方法，一般情况下查找的时间复杂度为O(1)。

InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应（adaptive）的。

自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引，InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。

- 预读(readahead)

预读（read-ahead)操作是一种IO操作，用于异步将磁盘的页读取到buffer pool中，预料这些页会马上被读取到。预读请求的所有页集中在一个范围内。

InnoDB使用两种预读算法：

**Linear read-ahead**：线性预读技术，预测在buffer pool中被访问到的数据它临近的页也会很快被访问到。如果一个extent中的被顺序读取的page超过或者等于该参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64的任何值(因为一个extent中也就只有64页)，默认值为56，值越高，访问模式检查越严格。

**Random read-ahead**: 随机预读，通过buffer pool中存中的页来预测哪些页可能很快会被访问，而不考虑这些页的读取顺序。random 预读放到以extent中的page为单位，着眼于将当前extent中的剩余的page提前读取到buffer pool中。

## 什么是索引？
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它
们包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，
以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种。

## 索引有哪几种类型？

**主键索引:**

数据列不允许重复，不允许为NULL。一个表只有一个主键。

**唯一索引:**

数据列不能重复，允许为Null值；一个表允许有多个唯一索引。

**普通索引:**

基本的索引类型，没有唯一性的限制，允许为NULL值。包括：普通索引，组合索引，全文索引。

## 一个mysql表最多可以有几列?一个mysql表最多可以创建多少个索引?单个索引最多可以包含多少个列?一个索引最多可以有多长?

**innoDB:** 最多创建1017列, 最多64个二级索引, 单个索引最多包含16列, 索引最大长度767字节(其实行格式为REDUNDANT,COMPACT最高为767字节,但行格式为DYNAMIC,COMPRESSED最高可达为3072字节), 行大小最大65536字节

**mysiam:** 最多4096列, 最多64个二级索引, 单个索引最多包含16列, 索引最大长度1000字节, 行大小最大65536字节


## InnoDB：B+树索引、全文索引、哈希索引

- 哈希索引是自适应的，也就是说这个不能人为干预在一张表生成哈希索引，InnoDB会根据这张表的使用情况来自动生成。

- 全文索引是将存在数据库的整本书的任意内容信息查找出来的技术，InnoDB从1.2.x版本支持。每张表只能有一个全文检索的索引。

- B+树索引是传统意义上的索引，B+树索引并不能根据键值找到具体的行数据，B+树索引只能找到行数据锁在的页，然后通过把页读到内存，再在内存中查找到行数据。B+树索引也是最常用的最为频繁使用的索引。

## 一棵聚集索引B+树可以放多少行数据？
这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。假设一行记录的数据大小为1k，那么单个叶子节点（页）中的记录数=16K/1K=16。

那么现在我们需要计算出非叶子节点能存放多少指针，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16kb/14b=1170。那么可以算出一棵高度为2的B+树，大概能存放1170*16=18720条这样的数据记录。

根据同样的原理我们可以算出一个高度为3的B+树大概可以存放：1170*1170*16=21902400行数据。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次逻辑IO操作即可查找到数据。

## Cardinality值
如何判断一个索引建立的是否好呢？可以用show index from指令查看Cardinality值，这个值是一个预估值，而不是一个准确值。每次对Cardinality值的统计都是随机取8个叶子节点得到的。实际应用中，（Cardinality/行数）应该尽量接近1.

对于innodb来说，达到以下2点就会重新计算cardinality：

- 如果表中1/16的数据发生变化
- 如果stat_modified_counter>200 000 0000

需要强制刷新Cardinality值的话可以用：
```$xslt
analyze local table xxx;
```
