---
title: Spring从入门到放弃
author: ynf
date: 2021-04-14 20:47:31 +0800
categories: [JAVA]
tags: [JAVA, Spring]
---
本文旨在记录Spring框架常见的用法，尽可能地将框架灵活运用起来。

### 一、Spring初识

### 二、IOC
##### 1、基本使用：
**(1) bean标签：**
```
<bean id="person" class="com.study.bean.Person"></bean>
```
常用属性：
id：bean的自定义id
class：指定具体的类名
scope：bean的作用域：singleton、prototype、request、session，默认情况下是单例的。多实例时，容器启动的时候不会创建多实例bean，只有在获取对象的时候才会创建该对象，每次创建都是一个新的对象；单实例则在容器启动完成之前就已经创建好对象，获取的所有对象都是同一个
parent：继承关系bean的配置，可以指定具体的类，也可以bean的id
factory-bean：指定使用哪个工厂实例，实例工厂方式生成对象
factory-method：指定哪个方法是工厂方法，配合class属性指定静态工厂类

> 在利用工厂模式创建bean实例的时候有两种方式，分别是静态工厂和实例工厂。静态工厂是指通过class属性指定静态工厂类，生成对象时调用工厂类的静态方法即可，不需要生成工厂对象；而实例工厂则需要先创建工厂实例，然后通过实例对象调用对应的生产对象方法。

init-method：指定对象初始化时调用方法
destroy-method： 指定对象销毁是调用的方法
>bean生命周期表示bean的创建到销毁
如果bean是单例，容器在启动的时候会创建好，关闭的时候会销毁创建的bean，初始化和销毁都会调用
如果bean是多例，获取的时候才创建对象，初始化时会调用，但销毁的时候不会有任何的调用
>注意：applicationContext没有close方法，需要使用具体的子类，使用：
((ClassPathXmlApplicationContext)context).close();

autowire：spring基于xml文件的自动装配，不需要手动给bean写内部属性，自动进行装配；
>其中default/no：不自动装配；byName：按照名字进行装配，以属性名作为id去容器中查找组件，进行赋值，如果找不到则装配null；byType：按照类型进行装配,以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的bean对象，那么会报异常，如果找不到则装配null；constructor：按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接装配null；如果按照类型找到了多个，那么就使用参数名作为id继续匹配，找到就装配，找不到就装配null

**(2) bean的子标签constructor-arg:**
```
<bean id="person" class="com.study.bean.Person">
    <constructor-arg value="1"></constructor-arg>
    <constructor-arg value="lisi"></constructor-arg>
    <constructor-arg value="20"></constructor-arg>
    <constructor-arg value="女"></constructor-arg>
</bean>
```
常用属性：
value：在使用构造器赋值的时候可以省略name属性，但是此时就要求必须严格按照构造器参数的顺序来填写了
index：如果想不按照顺序来添加参数值，那么可以搭配index属性来使用
type：当有多个参数个数相同，不同类型的构造器的时候，可以通过type来强制类型

**bean的子标签property：**给复杂的属性赋值
```
<bean id="person" class="com.study.bean.Person">
    <property name="name">
        <!--赋空值-->
        <null></null>
    </property>
    <!--通过ref引用其他对象，引用外部bean-->
    <property name="address" ref="address"></property>
    <!--引用内部bean-->
    <!-- <property name="address">
        <bean class="com.study.bean.Address">
            <property name="province" value="北京"></property>
            <property name="city" value="北京"></property>
            <property name="town" value="西城区"></property>
        </bean>
    </property>-->
    <!--为list赋值-->
    <property name="books">
        <list>
            <!--内部bean-->
            <bean id="book1" class="com.study.bean.Book">
                <property name="name" value="多线程与高并发"></property>
                <property name="author" value="laoma"></property>
                <property name="price" value="1000"></property>
            </bean>
            <!--外部bean-->
            <ref bean="book2"></ref>
        </list>
    </property>
    <!--给map赋值-->
    <property name="maps" ref="myMap"></property>
    <!--给property赋值-->
    <property name="properties">
        <props>
            <prop key="aaa">aaa</prop>
            <prop key="bbb">222</prop>
        </props>
    </property>
    <!--给数组赋值-->
    <property name="hobbies">
        <array>
            <value>book</value>
            <value>movie</value>
            <value>game</value>
        </array>
    </property>
    <!--给set赋值-->
    <property name="sets">
        <set>
            <value>111</value>
            <value>222</value>
            <value>222</value>
        </set>
    </property>
</bean>
```
常用属性：
name：属性名称
value： 属性值
ref：引用对应的bean的id

**(3) 通过命名空间为bean赋值，简化配置文件中属性声明的写法**
```
<?xml version="1.0" encoding="UTF-8"?>
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"
>

<!-- 添加配置 -->
<bean id="person" class="com.study.bean.Person" p:id="3" p:name="wangwu" p:age="22" p:gender="男"></bean>

<!--util名称空间创建集合类型的bean-->
<util:map id="myMap">
        <entry key="key1" value="value1"></entry>
        <entry key="key2" value-ref="book2"></entry>
        <entry key="key03">
            <bean class="com.study.bean.Book">
                <property name="name" value="西游记" ></property>
                <property name="author" value="吴承恩" ></property>
                <property name="price" value="100" ></property>
            </bean>
        </entry>
</util:map>
```

#### 2、配置bean对象初始化方法的前后处理方法
spring中包含一个BeanPostProcessor的接口，可以在bean的初始化方法的前后调用该方法，如果配置了初始化方法的前置和后置处理器，无论是否包含初始化方法，都会进行调用
```
package com.study.bean;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanPostProcessor implements BeanPostProcessor {
    /**
     * 在初始化方法调用之前执行
     * @param bean  初始化的bean对象
     * @param beanName  xml配置文件中的bean的id属性
     * @return
     * @throws BeansException
     */
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization:"+beanName+"调用初始化前置方法");
        return bean;
    }

    /**
     * 在初始化方法调用之后执行
     * @param bean
     * @param beanName
     * @return
     * @throws BeansException
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization:"+beanName+"调用初始化后缀方法");
        return bean;
    }
}
```

#### 3、spring创建第三方bean对象
首先，引入对应的pox依赖：
```
<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.21</version>
</dependency>
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
```
其次，编写配置文件：
```
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="username" value="root"></property>
    <property name="password" value="123456"></property>
    <property name="url" value="jdbc:mysql://localhost:3306/demo"></property>
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
</bean>
```

#### 4、spring引用外部配置文件
在resource中添加dbconfig.properties
```
username=root
password=123456
url=jdbc:mysql://localhost:3306/demo
driverClassName=com.mysql.jdbc.Driver
```
编写配置文件
```
<!--加载外部配置文件
    在加载外部依赖文件的时候需要context命名空间 
-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

<!-- 将下面的内容添加到对应的beans标签内 -->
<context:property-placeholder location="classpath:dbconfig.properties"/>
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="username" value="${username}"></property>
    <property name="password" value="${password}"></property>
    <property name="url" value="${url}"></property>
    <property name="driverClassName" value="${driverClassName}"></property>
</bean>
```

#### 5、SpEL的使用：SpEL:Spring Expression Language,spring的表达式语言，支持运行时查询操作对象
```
<bean id="address" class="com.study.bean.Address">
    <property name="province" value="河北"></property>
    <property name="city" value="邯郸"></property>
    <property name="town" value="武安"></property>
</bean>
<bean id="person4" class="com.study.bean.Person">
    <!--支持任何运算符-->
    <property name="age" value="#{12*2}"></property>
    <!--可以引用其他bean的某个属性值-->
    <property name="name" value="#{address.province}"></property>
    <!--引用其他bean-->
    <property name="address" value="#{address}"></property>
    <!--调用静态方法-->
    <property name="hobbies" value="#{T(java.util.UUID).randomUUID().toString().substring(0,4)}"></property>
    <!--调用非静态方法-->
    <property name="gender" value="#{address.getCity()}"></property>
</bean>
```

#### 6、注解使用
**(1) Spring中包含4个主要的组件添加注解：**
@Controller:控制器，推荐给controller层添加此注解
@Service:业务逻辑，推荐给业务逻辑层添加此注解
@Repository:仓库管理，推荐给数据访问层添加此注解
@Component:给不属于以上基层的组件添加此注解

>注意：我们虽然人为的给不同的层添加不同的注解，但是在spring看来，可以在任意层添加任意注解，spring底层是不会给具体的层次验证注解，这样写的目的只是为了提高可读性，最偷懒的方式，就是给所有想交由IOC容器管理的bean对象添加component注解


**(2) 使用注解的步骤：**
a、添加上述四个注解中的任意一个
b、添加自动扫描注解的组件，此操作需要依赖context命名空间
c、添加自动扫描的标签context:component-scan
```
<!--
定义自动扫描的基础包:
base-package:指定扫描的基础包，spring在启动的时候会将基础包及子包下所有加了注解的类都自动
            扫描进IOC容器
-->
<context:component-scan base-package="com.study"></context:component-scan>
```
```
//PersonController.java
package com.study.controller;

import org.springframework.stereotype.Controller;

@Controller
public class PersonController {
    public PersonController() {
        System.out.println("创建对象");
    }
}

//PersonDao.java
package com.study.dao;

import org.springframework.stereotype.Repository;

@Repository("personDao")
@Scope(value="prototype")
public class PersonDao {
}
```
>注意：当使用注解注册组件和使用配置文件注册组件是一样的，但是要注意：
1、组件的id默认就是组件的类名首字符小写，如果非要改名字的话，直接在注解中添加即可
2、组件默认情况下都是单例的,如果需要配置多例模式的话，可以在注解下添加@Scope注解

**(3) 定义扫描宝石要包含的类和不要包含的类：**
当定义好基础扫描的包之后，可以排除包中的某些类，使用如下的方式:
type:表示指定过滤的规则
annotation：按照注解进行排除，标注了指定注解的组件不要,expression表示要过滤的注解完整类名
assignable：指定排除某个具体的类，按照类排除，expression表示不注册的具体类名
aspectj：后面讲aop的时候说明要使用的aspectj表达式，不用
custom：定义一个typeFilter,自己写代码决定哪些类被过滤掉，不用
regex：使用正则表达式过滤，不用

**(4) 使用@AutoWired进行自动注入：**
```
package com.study.controller;

import com.study.service.PersonService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class PersonController {

    @Autowired
    private PersonService personService;

    public PersonController() {
        System.out.println("创建对象");
    }

    public void getPerson(){
        personService.getPerson();
    }
}
```
>注意：当使用AutoWired注解的时候，自动装配的时候是根据类型实现的。
1、如果只找到一个，则直接进行赋值，
2、如果没有找到，则直接抛出异常，
3、如果找到多个，那么会按照变量名作为id继续匹配,
&nbsp;&nbsp;&nbsp;&nbsp;1、匹配上直接进行装配
&nbsp;&nbsp;&nbsp;&nbsp;2、如果匹配不上则直接报异常

**(4) 其他注解：**
@Qualifier：用来指定id的名称，让spring不要使用变量名
>当使用@Qualifier注解的时候也会有两种情况：
1、找到，则直接装配
2、找不到，就会报错

**(5) 自动装配的注解@AutoWired，@Resource**
在使用自动装配的时候，出了可以使用@AutoWired注解之外，还可以使用@Resource注解。两个注解的区别:
1、@AutoWired:是spring中提供的注解，@Resource:是jdk中定义的注解，依靠的是java的标准
2、@AutoWired默认是按照类型进行装配，默认情况下要求依赖的对象必须存在，@Resource默认是按照名字进行匹配的，同时可以指定name属性。
3、@AutoWired只适合spring框架，而@Resource扩展性更好

**(6) 泛型依赖注入**
BaseService.java
```
package com.study.service;

import com.study.dao.BaseDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

public class BaseService<T> {
    
    @Autowired
    BaseDao<T> baseDao;
    
    public void save(){
        System.out.println("自动注入的对象："+baseDao);
        baseDao.save();
    }
}
```
StudentService.java
```
package com.study.service;

import com.study.bean.Student;
import com.study.dao.StudentDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StudentService extends BaseService<Student> {
}
```

### 二、AOP
##### 1 AOP理解

#### 2 基本使用
##### 2.1 添加pom依赖：
```
<!-- https://mvnrepository.com/artifact/cglib/cglib -->
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.5</version>
</dependency>
<!-- https://mvnrepository.com/artifact/aopalliance/aopalliance -->
<dependency>
    <groupId>aopalliance</groupId>
    <artifactId>aopalliance</artifactId>
    <version>1.0</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.2.3.RELEASE</version>
</dependency>
```
##### 2.2 基于注解的AOP功能
- 通过@Component将切面类加入到IOC容器中，@Aspect设置切面类;
- 设置程序中的切面类：使用@Aspect注解；
- 设置切面类中的方法是在什么时候、哪里执行；
```
package com.study.util;

import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.Arrays;

@Component
@Aspect
public class LogUtil {

    /*
    设置下面方法在什么时候运行
        @Before:在目标方法之前运行：前置通知
        @After:在目标方法之后运行：后置通知
        @AfterReturning:在目标方法正常返回之后：返回通知
        @AfterThrowing:在目标方法抛出异常后开始运行：异常通知
        @Around:环绕：环绕通知

        当编写完注解之后还需要设置在哪些方法上执行，使用表达式
        execution(访问修饰符  返回值类型 方法全称)
     */
    @Before("execution( public int com.study.inter.MyCalculator.*(int,int))")
    public static void start(){
//        System.out.println("XXX方法开始执行，使用的参数是："+ Arrays.asList(objects));
//        System.out.println(method.getName()+"方法开始执行，参数是："+ Arrays.asList(objects));
        System.out.println("方法开始执行，参数是：");
    }

    @AfterReturning("execution( public int com.study.inter.MyCalculator.*(int,int))")
    public static void stop(){
//        System.out.println("XXX方法执行结束，结果是："+ Arrays.asList(objects));
//        System.out.println(method.getName()+"方法执行结束，结果是："+ Arrays.asList(objects));
        System.out.println("方法执行完成，结果是：");

    }

    @AfterThrowing("execution( public int com.study.inter.MyCalculator.*(int,int))")
    public static void logException(){
//        System.out.println(method.getName()+"方法出现异常："+ e.getMessage());
        System.out.println("方法出现异常：");
    }

    @After("execution( public int com.study.inter.MyCalculator.*(int,int))")
    public static void end(){
//        System.out.println(method.getName()+"方法执行结束了......");
        System.out.println("方法执行结束了......");
    }
}
```
- 开启基于注解的aop的功能：
```
xmlns:aop="http://www.springframework.org/schema/aop"
http://www.springframework.org/schema/aop
https://www.springframework.org/schema/aop/spring-aop.xsd">

<context:component-scan base-package="com.study"></context:component-scan>
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

##### 2.3 基于配置的AOP功能
- 删除上面所有的注解，并添加aop.xml文件：
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd
">

    <context:component-scan base-package="com.study"></context:component-scan>
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

    <bean id="logUtil" class="com.study.util.LogUtil2"></bean>
    <bean id="securityAspect" class="com.study.util.SecurityAspect"></bean>
    <bean id="myCalculator" class="com.study.inter.MyCalculator"></bean>
    <aop:config>
        <aop:pointcut id="globalPoint" expression="execution(public int com.study.inter.MyCalculator.*(int,int))"/>
        <aop:aspect ref="logUtil">
            <aop:pointcut id="mypoint" expression="execution(public int com.study.inter.MyCalculator.*(int,int))"/>
            <aop:before method="start" pointcut-ref="mypoint"></aop:before>
            <aop:after method="end" pointcut-ref="mypoint"></aop:after>
            <aop:after-returning method="stop" pointcut-ref="mypoint" returning="result"></aop:after-returning>
            <aop:after-throwing method="logException" pointcut-ref="mypoint" throwing="exception"></aop:after-throwing>
            <aop:around method="myAround" pointcut-ref="mypoint"></aop:around>
        </aop:aspect>
        <aop:aspect ref="securityAspect">
            <aop:before method="start" pointcut-ref="globalPoint"></aop:before>
            <aop:after method="end" pointcut-ref="globalPoint"></aop:after>
            <aop:after-returning method="stop" pointcut-ref="globalPoint" returning="result"></aop:after-returning>
            <aop:after-throwing method="logException" pointcut-ref="globalPoint" throwing="exception"></aop:after-throwing>
            <aop:around method="myAround" pointcut-ref="mypoint"></aop:around>
        </aop:aspect>
    </aop:config>
</beans>
```

#### 3.jdk自带的动态代理和cglib动态代理
##### 3.1 jdk自带的动态代理

##### 3.2 cglib动态代理
MyCalculator.java
```
package com.mashibing.inter;

import org.springframework.stereotype.Service;

@Service
public class MyCalculator {
    public int add(int i, int j) {
        int result = i + j;
        return result;
    }

    public int sub(int i, int j) {
        int result = i - j;
        return result;
    }

    public int mult(int i, int j) {
        int result = i * j;
        return result;
    }

    public int div(int i, int j) {
        int result = i / j;
        return result;
    }
}
```
MyTest.java
```
public class MyTest {
    public static void main(String[] args){
        ApplicationContext context = new ClassPathXmlApplicationContext("aop.xml");
        MyCalculator bean = context.getBean(MyCalculator.class);
        bean.add(1,1);
        System.out.println(bean);
        System.out.println(bean.getClass());
    }
}
```
>综上所述：在spring容器中，如果有接口，那么会使用jdk自带的动态代理，如果没有接口，那么会使用cglib的动态代理。

### 三、IOC容器的理解

### 四、AOP的理解

### 五、Spring源码理解
